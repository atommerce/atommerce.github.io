[
   
      {
        "title"    : "슬랙에서 웹훅 연동하기",
        "category" : "",
        "tags"     : " 슬랙, 웹훅, slack, webhook",
        "url"      : "/2019/07/08/tonyji_slack-webhook.html",
        "date"     : "July 8, 2019",
        "excerpt"  : "스타트업에서 신속하고 효율적인 커뮤니케이션은 아주 중요한 요소 중 하나입니다. \n기업에서 활용할 수 있는 많은 커뮤니케이션 툴 중에서 슬랙은 현재 많은 스타트업에서 활용 중인 좋은 서비스로 기본적으로 무료로 제공됩니다. 다만, 몇 가지 프리미엄 기능을 사용하기 위해서는 유료 서비스를 신청하셔야 합니다. 무료 서비스는 주고 받는 메시지의 최대 기록이 일정 수(현재 10,000개)로 제한되어 그 수를 넘게 되면 과거...",
        "content"  : "스타트업에서 신속하고 효율적인 커뮤니케이션은 아주 중요한 요소 중 하나입니다. \n기업에서 활용할 수 있는 많은 커뮤니케이션 툴 중에서 슬랙은 현재 많은 스타트업에서 활용 중인 좋은 서비스로 기본적으로 무료로 제공됩니다. 다만, 몇 가지 프리미엄 기능을 사용하기 위해서는 유료 서비스를 신청하셔야 합니다. 무료 서비스는 주고 받는 메시지의 최대 기록이 일정 수(현재 10,000개)로 제한되어 그 수를 넘게 되면 과거의 메시지들은 조회할 수 없게 됩니다. 또한, 파일 공유를 위한 스토리지 용량이 제한(현재는 5G)되는데 이 제한을 넘게되면 과거의 파일부터 기록에서 삭제됩니다. 이 특성만 고려한다면 무료로도 충분히 잘 활용할 수 있습니다.\n개인적으로 슬랙은 즉각적이거나 혹은 일정 기간동안만 유지되는 커뮤니케이션을 위해 활용하고, 기록으로 남기는 부분은 이메일, 지라(Jira), 트렐로(Trello), 구글 드라이브등의 다른 서비스들을 활용하는게 좋다고 생각합니다\n이번에 공유해 드릴 내용은 슬랙에서 제공하는 API 중에 웹훅을 활용한 기능입니다. 이 기능은 외부 시스템에서 특정 작업을 실행한 후 이를 슬랙을 통해 공유할 수 있도록 합니다.\n예를 들어 볼까요? 매일 아침 10시에 전날 서비스 가입자, 리텐션 등 각종 통계 정보를 슬랙을 통해 공유한다면 어떨까요? 혹은 서비스에 크리티컬한 오류가 발생할 경우, 슬랙에 알림을 보내는 것도 유용하겠죠?\n이처럼 슬랙의 웹훅 기능은 다양하게 활용할 수 있습니다.\n\n\n참고\n\n  Webhook(웹훅)이란? 서버에서 특정 작업이 수행 되었을 때, 해당 작업이 수행되었음을 HTTP POST 방식으로 알리는 개념을 말합니다.\n\n\n\n이제부터 본격적으로 슬랙의 웹훅 기능을 구현하도록 해보겠습니다.\n\n\n먼저, 다음 링크를 통해서 슬랙 API 웹사이트에 접속합니다.\n\n  https://api.slack.com/incoming-webhooks\n\n\n\n화면 중앙의 “Create your Slack app” 버튼을 클릭해서 슬랙 앱을 생성합니다. \n\n\n\n\n그런 다음 원하는 이름으로 “App Name”을 기술하고, “Development Slack Workspace”에 팀이 사용중인 workspace를 선택합니다. 기존에 사용하는 workspace가 없는 경우 새로 생성한 후에 작업을 계속하면 됩니다. \n기입이 다 완료되면 하단의 “Create App” 버튼을 클릭합니다.\n\n\n\n이후 슬랙을 위한 기능을 추가하는데 여기에서 “Incoming Webhooks”를 선택하고 하단의 “Save Changes”를 클릭합니다.\n\n\n\n\n\n\n웹훅 설정화면에서 “Activate Imcoming Webhook”를 “On” 상태로 바꿉니다. \n\n\n\n\n\n\n맨 하단의 “Add New Webhook to Workspace”를 클릭하면, 다음과 같이 알림을 받을 채널을 선택하는 화면이 뜹니다. 원하는 채널을 선택한 후 “Install” 버튼을 클릭하면 해당 채널로 웹훅 알림이 전달됩니다.\n\n\n\n\n\n\n자, 이제 모든 설정을 완료했습니다. \n\n화면 중앙의 “Sample curl request to post to a channel”에 나온 curl 실행 명령을 복사합니다. \n\n\n\n\n\n 터미널에서 복사한 curl 명령을 붙여넣기해서 실행해보면 지정한 채널로 “Hello, World!”라는 텍스트가 발송되는 것을 확인하실 수 있습니다.\n\n\n\n\n\n우리는 “# general” 채널로 텍스트를 발송했으므로 아래와 같이 “# general” 채널로 “Hello, World!”라는 텍스트가 올라온 것을 볼 수 있습니다. 발송자는 맨 처음에 “App Name”으로 지정했던 “Super Service”로 나타납니다.\n\n\n\n\n\n이제 슬랙 웹훅을 위한 모든 준비가 끝났습니다. \n웹훅 설정 화면에서 아래 화면과 같이 “Webhook URL”에서 Copy 버튼을 클릭해서 복사해 두세요.\n\n\n\n\n\n\n이제 남은 작업은 여러분이 원하는 정보를 생성하는 데몬 프로그램을 구현해서 원하는 주기로 위에서 복사하셨던 “Webhook URL”로 POST 방식으로 전송하기만 하면 됩니다. 참 쉽죠^^\n\n슬랙의 웹훅 기능은 정말 유용한 기능이에요. 아직 활용하지 않았던 스타트업이 있으면 적극적으로 활용해 보세요.\n\n\n세상의 모든 스타트업을 응원합니다!\n감사합니다.\n"
      } ,
   
      {
        "title"    : "MySQL에서 이모지 사용하기",
        "category" : "",
        "tags"     : " utf8, utf8mb4, mysql, 유니코드, 이모지, UTF-8",
        "url"      : "/2019/07/07/tonyji_utf8mb4.html",
        "date"     : "July 7, 2019",
        "excerpt"  : "\n올해 초 각고의 노력 끝에 아토머스의 오랜 숙원 사업인 ‘마인드카페 프로’를 런칭하게 되었습니다.\n마인드카페 프로는 기존의 오프라인 대면 심리 상담 방식을 온라인 익명 채팅 및 전화상담으로 구현한 서비스입니다.\n오늘은 마인드카페 프로의 기능 중 채팅 상담을 구현하면서 겪은 이슈인 이모지 사용을 위한 MySQL 인코딩에 대해 말씀드리려고 합니다.\n\n\n사실 필자는 오랜 기...",
        "content"  : "\n올해 초 각고의 노력 끝에 아토머스의 오랜 숙원 사업인 ‘마인드카페 프로’를 런칭하게 되었습니다.\n마인드카페 프로는 기존의 오프라인 대면 심리 상담 방식을 온라인 익명 채팅 및 전화상담으로 구현한 서비스입니다.\n오늘은 마인드카페 프로의 기능 중 채팅 상담을 구현하면서 겪은 이슈인 이모지 사용을 위한 MySQL 인코딩에 대해 말씀드리려고 합니다.\n\n\n사실 필자는 오랜 기간동안 백엔드 프로그래밍을 해왔는데, MySQL에서 다국어 지원을 위해서는 ‘utf8’ 을 사용해야 한다고 알고 있었고 항상 기본 인코딩으로 ‘utf8’을 사용해 왔습니다. 그런데, 채팅에서 이모지 사용을 테스트하던 중 이모지가 제대로 표현되지 않는 오류를 발견하고 이를 분석하던 중 새로운 사실을 알게 되어 공유드리려고 합니다.\n\n본론에 들어가기 전에 우선 인코딩에 대해서 간략하게 정리해 보도록 하겠습니다.\n\n\n히스토리\n\n컴퓨터에서 문자를 표시하기 위해 각 문자에 수치화된 코드값을 부여한 것을 ‘문자 집합’이라고 합니다.\n그리고, 이 문자 집합을 컴퓨터가 이해할 수 있도록 비트 단위로 변환하는 작업을 ‘인코딩’이라고 합니다.\n\n컴퓨터가 발명된 후, 각 나라마다 자국의 언어에 맞는 문자 집합을 정의해서 사용해왔는데, 이러다 보니 인코딩 방식이 서로 달라서 여러 국가의 언어를 동시에 표시하는데 문제가 발생하게 됩니다.\n이에 따라, 전 세계 모든 문자에 대한 표준 문자 집합인 ‘유니코드’가 탄생하게 되었습니다. 유니코드에 대한 자세한 설명은 위키백과의 설명을 참고하세요.\n\n유니코드의 주요 인코딩 방식에는 UTF-8, UTF-16, UTF-32등이 있는데, 이 중 UTF-16은 기본 다국어 평면(BMP, Basic multilingual plane)에 속하는 기본 문자들은 16비트(즉, 2바이트)로 그 이상의 문자는 32비트로 인코딩하고, UTF-32는 모든 문자를 32비트(즉, 4바이트)의 고정된 크기로 인코딩하도록 정의되어 있습니다. \n그 중, UTF-8은 문자에 따라 8비트부터 32비트(즉, 1바이트~4바이트)까지 표현되는 가변 길이 문자 인코딩 방식으로 ASCII 코드와 호환되는 동시에 유니코드를 표현할 수 있어 가장 많이 사용된다고 합니다.\n\n그렇다면, MySQL ‘utf8’이라는 인코딩이 무엇을 의미하는지 부터 알아보겠습니다.\nMySQL에서 유니코드에 대한 지원은 2003년에 발표된 MySQL 4.1 버전부터이며, 위에서 설명드린 유니코드의 표준 인코딩 방식 중 UTF-8 방식을 ‘utf8’이라는 명칭으로 지원하면서 시작되었습니다.\n\n그런데, 문제는 현재의 UTF-8 표준인 RFC 3629가 제정되기 이전이어서 당시의 UTF-8 표준인 RFC 2279를 바탕으로 개발이 진행되었다는 것입니다. \nRFC 2279에서는 한 문자당 6바이트를 할당하는 방식이었고, MySQL 개발자들은 정확한 이유는 밝혀지지 않았지만 3바이트까지만으로 제한한 방식으로 ‘utf8’을 구현한 것 입니다. \n이에 대한 내용을 분석한 다음 블로그에서 꽤 설득력 있는 원인을 찾을 수 있습니다.\n\nMySQL에서는 그 이후에도 별다른 공지 없이 UTF-8을 ‘utf8’로 사용하면 된다는 식으로 가이드를 제공해왔습니다. \n따라서, 많은 개발자가 별다른 고민없이 이를 따르게 됐죠. 그러던 중, MySQL에서는 현재 표준에 맞게 4바이트를 모두 지원하는 인코딩 방식인 ‘utf8mb4’를 포함한 새로운 버전인 MySQL 5.5.3 버전을 2010년에 공식 발표하게 됩니다.\n원래대로라면 ‘utf8’은 UTF-8을 완전히 지원하지 않기 때문에 이를 완전히 지원하는 ‘utf8mb4’를 사용하도록 충분한 가이드가 제공되었어야겠지만, MySQL은 그러질 않았어요.\n그래서, 현재까지도 많은 개발자가 MySQL에서 UTF-8을 ‘utf8’로 잘못 인식해서 이모지와 같은 일부 문자들이 제대로 표시되지 않는 황당한 오류를 겪게 되는 것이죠. \n자, 그렇다면 이제 기존의 utf8 인코딩을 utf8mb4로 바꾸는 방법을 알아보도록 하시죠.\n\n\nutf8mb4 설정하기\n\n우선, MySQL의 my.cnf 설정파일을 다음과 같이 수정합니다.\n\n\n  $ sudo vi /etc/my.cnf\n\n\n   [client]\n   default-character-set = utf8mb4\n \n   [mysqld]\n   character-set-server = utf8mb4\n   collation-server = utf8mb4_unicode_ci\n \n   [mysql]\n   default-character-set = utf8mb4\n\n\n설정을 변경 한 후에는 다음과 같이 MySQL 서버를 재시작 시켜주세요.\n\n  $ sudo service mysqld restart\n\n\n그런 다음, 다음과 같이 MySQL 터미널로 접속해서 변수들이 잘 변경되었는지 확인해 봅니다.\n\n  $ mysql -uroot -p\nmysql&amp;gt; SHOW VARIABLES LIKE ‘char%’; SHOW VARIABLES LIKE ‘collation%’;\n\n\n\n\n위와 같이 보이신다면 잘 변경된 것입니다. 이때, character_set_system은 ‘utf8’로 표시되는 것이 정상입니다.\n\n\n업데이트를 위한 체크 사항\n마지막으로, 기존 테이블을 업데이트하려면 다음과 같이 진행하면 됩니다.\nutf8mb4는 utf8과 100% 호환되기 때문에 문자가 깨질 염려는 하지 않으셔도 됩니다. \n다만, 3바이트였던 자릿수가 4바이트로 늘어나면서 칼럼의 최대 길이와 인덱스 키의 길이를 체크해야 합니다.\n\n예를 들어, TINYTEXT 칼럼은 255바이트까지 저장할 수 있는데,  utf8인 경우 3바이트 문자 기준 85개, utf8mb4의 경우 4바이트 문자 기준 63개를 저장할 수 있습니다.\n따라서, 기존에 TINYTEXT 칼럼을 사용한다면 최대 입력 문자 수를 줄이거나 TEXT와 같은 필드로 칼럼 타입을 수정해야겠죠. \n인덱스 키의 경우도 InnoDB 스토리지 엔진은 최대 767바이트까지만 인덱스를 저장할 수 있는데, 이를 3바이트(utf8인 경우)으로 나누면 255자, 4바이트(utf8mb4)로 나누면 191자까지만 인덱싱이 가능하다는 의미입니다. \n이 경우, VARCHAR(255)로 정의된 필드에 인덱스가 걸려있었다면, 이 필드에 인덱스를 유지하기 위해서는 VARCHAR(191)로 수정해야 합니다. \n\n위와 같은 체크가 완료되었다면 다음과 같이 테이블을 업데이트시켜 주시면 됩니다.\n\n\n  mysql&amp;gt; use 데이터베이스명\nmysql&amp;gt; ALTER TABLE 테이블명 CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n\n\n참고로 파이썬에서 SQLAlchemy를 사용하실때 utf8mb4 사용을 위한 설정은 다음과 같습니다.\n\n\n  $ vi config.py\nSQLALCHEMY_DATABASE_URI=mysql+mysqlconnector://{username}:{password}@{hostname}/{databasename}?charset=utf8mb4\n\n\n\n\n여기까지 잘 따라오셨다면, 이제부터 이모지 문자가 잘 저장되는 것을 확인하실 수 있으실 겁니다.\n프로그래밍의 세계에서 인코딩은 난해한 영역에 해당합니다. 따라서, 이 부분은 많이 공부하고 디테일하게 파헤쳐볼 만 하답니다.\n더 깊은 내용을 공부하고 싶으신 분들을 위해 아래 참고 링크를 정리했습니다.\n시간 되실 때 정독하시면 좋을 것 같네요.\n감사합니다.\n\n\n\n참고 자료\n\n\n  유니코드 설명(출처:위키백과)\n  UTF-8 설명(출처:위키백과)\n  한글 인코딩의 이해(출처:네이버D2 기술블로그)\n  How to support full Unicode in MySQL databases\n\n\n"
      } ,
   
      {
        "title"    : "함수형 컴포넌트와 React Hooks",
        "category" : "",
        "tags"     : " react, react hooks",
        "url"      : "/2019/06/30/react-hooks.html",
        "date"     : "June 30, 2019",
        "excerpt"  : "들어가며\n\n리엑트는 컴포넌트를 정의하는 데 있어서 두 가지의 방법을 사용할 수 있습니다. 첫 번째 방법은 클래스로 정의하는 방법이며 두 번째는 함수로 정의하는 방법이 있습니다. 두 방법의 차이점은 함수로 정의한 컴포넌트는 뷰를 그려내기만 하는 데에 초점이 맞춰진 컴포넌트이기 때문에 컴포넌트 내에서 state를 사용할 수 없으며 생명주기 메서드를 사용할 수 없다는 점입니다. 하...",
        "content"  : "들어가며\n\n리엑트는 컴포넌트를 정의하는 데 있어서 두 가지의 방법을 사용할 수 있습니다. 첫 번째 방법은 클래스로 정의하는 방법이며 두 번째는 함수로 정의하는 방법이 있습니다. 두 방법의 차이점은 함수로 정의한 컴포넌트는 뷰를 그려내기만 하는 데에 초점이 맞춰진 컴포넌트이기 때문에 컴포넌트 내에서 state를 사용할 수 없으며 생명주기 메서드를 사용할 수 없다는 점입니다. 하지만 리엑트 16.8버전부터 Hooks라는 새로운 기능이 도입되어 함수형 컴포넌트에 날개를 달아 주었습니다. 이번 포스팅에서는 Hooks에 대해 알아보도록 하겠습니다.\n\n\n\n\n함수형 컴포넌트 VS 클래스 컴포넌트\n\n함수형 컴포넌트를 정의해서 사용하다가 state를 사용해야 하거나 생명주기 함수들이 필요하면 클래스 컴포넌트로 변경하는 경험을 리엑트 개발자라면 해보셨을 겁니다. 구조가 크게 다르지 않아 공수가 많이 드는 것은 아니지만 “이럴 거면 처음부터 클래스 컴포넌트로 정의할걸…” 이라는 생각을 하게 되기 마련인데요. 이럴 때면 함수형 컴포넌트는 클래스로 정의한 컴포넌트의 모든 기능을 대신할 수 없기 때문에 굳이 사용해야 할 이유를 느끼지 못하는 정의 방법이라고 치부하기 쉽고 아예 클래스 컴포넌트만을 사용해서 개발을 진행하는 경우도 있을 겁니다.\n\n하지만 이렇게 기능이 부족한 함수형 컴포넌트도 나름대로 존재 이유가 있습니다.\n\n\n  “뷰를 그리기 위한 컴포넌트다”라는 명시적인 효과\n  간단한 구조에서 오는 가독성의 증가\n  렌더링 될 때의 props를 유지\n\n\n일단 함수형 컴포넌트는 뷰에 집중하는 컴포넌트라는 느낌을 강하게 주며 코드량이 적고 간단한 구조 때문에(기능이 적으니 당연히…) 코드의 가독성이 좋습니다. 이러한 점에서 리덕스로 상태관리를 하는 리엑트 앱에서는 스토어와 긴밀한 관계를 유지 “컨테이너 컴포넌트”와 컨테이너 컴포넌트로부터 전달받은 데이터를 화면에 그리는 “프리젠테이셔널 컴포넌트”으로 구분하여 컴포넌트를 정의하며 프리젠테이셔널 컴포넌트는 상태를 필요로 하지 않기 때문에 함수형 컴포넌트로 작성됩니다. 마지막 항목인 렌더링 될 때의 props를 유지한다는 특징은 비동기 함수 내에서 props에 접근 시의 버그에 관련된 내용으로써 Dan Abramov님의 포스팅을 참고하시면 도움이 될 것 같습니다.\n\n\n\nReact Hooks\n\nHooks는 리엑트를 함수형 프로그래밍 방식으로 개발하고자 했던 recompose프로젝트에서 시작되었으며 프로젝트를 진행한 개발자가 리엑트 팀에 합류되면서 Hooks가 릴리즈 되었습니다. Hooks라는 기능은 함수형 컴포넌트에서도 state와 생명주기 메서드를 사용 가능하게 해줍니다. React Hooks의 종류는 다음과 같습니다.\n\n\n  기본 Hooks\n    \n      useState\n      useEffect\n      useContext\n    \n  \n  추가 Hooks\n    \n      useReducer\n      useCallback\n      useMemo\n      useRef\n      useImperativeHandle\n      useLayoutEffect\n      useDebugValue\n    \n  \n\n\n\n\nuseState Hook\n\nHooks는 함수 형태로 기능을 제공합니다. 대표적인 Hooks는 바로 useState입니다. 컴포넌트에서 state를 사용하게 해주는 함수로써 Hooks를 사용한다면 가장 많이 사용하게 될 함수가 바로 useState입니다.\n\n다음은 클래스 컴포넌트를 사용해서 만든 간단한 카운터 예제입니다.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nimport React, { Component } from &#39;react&#39;;\n\nclass Counter extends Component{\n  state = { count: 0 }\n\n  increase = () =&amp;gt; {\n    this.setState(prevState =&amp;gt; ({count: prevState.count + 1}));\n  }\n\n  render(){\n    return &amp;lt;button onClick={this.increase}&amp;gt;{this.state.count}&amp;lt;/button&amp;gt;\n  }\n}\n\n\n다음은 위의 예제를 함수형 컴포넌트와 userState Hook을 이용해서 리팩토링 했습니다.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nimport React, { useState } from &#39;react&#39;;\n\nfunction Counter(){\n  const [ count, setCount ] = useState(0);\n\n  const increase = () =&amp;gt; {\n    setCount(count + 1);\n  }\n\n  return &amp;lt;button onClick={increase}&amp;gt;{count}&amp;lt;/button&amp;gt;\n}\n\n\nuseState라는 함수는 파라미터로 사용하고자 하는 state의 기본값(0)을 받으며 배열을 리턴합니다. 배열의 첫 번째 요소는 현재 state(count)의 값이며 두 번째 요소는 state를 갱신할 수 있는 함수입니다. 여기서 예리한 눈을 가지신 분들은 “useState함수가 매번 0을 리턴할 것인데 어떻게 카운터를 만들 수 있나” 라는 의문을 가지실 수도 있습니다.\n\nuseState는 렌더링 될 때마다 계속 실행되는 것이 맞지만 매번 초깃값을 리턴하는 것이 아니며 setCount에 의해 갱신된 count 값을 유지합니다. 그래서 createState라는 이름 대신 useState라는 함수명을 갖게 되었습니다.\n\n\n\nuseEffect Hook\n\n함수형 컴포넌트에서는 생명주기 함수를 사용할 수 없습니다. 리엑트에서 클래스 컴포넌트는 다음과 같은 다양한 생명주기 함수를 가집니다.\n\n\n  constructor - 생성자\n  componentWillMount - 컴포넌트가 마운트 되기 전\n  componetDidMount - 컴포넌트가 마운트 된 후\n  componentWillReciveProps - 컴포넌트에 새로운 props가 전달 되기 전\n  shouldComponentUpdate - 컴포넌트가 rerender 되어야할지 결정\n  componentWillUpdate - 컴포넌트가 rerender 되기 전\n  componentDidUpdate - 컴포넌트가 rerender 된 후\n  render - render함수\n  componentWillUnmount - 컴포넌트가 제거되기 전\n\n\n함수형 컴포넌트는 위 생명주기 함수 중에서 오직 render함수의 기능밖에 하지 못하기(render함수 그 자체라고 봐도 무방) 때문에 기능적, 성능적인 면에서 제약이 있습니다. 예를 들면 컴포넌트가 마운트 된 후 API를 호출해야하는 경우, 컴포넌트가 언마운트 되기 전에 이벤트를 해제해야하는 경우들이 있습니다.\n\n이런 한계를 극복해주는 Hooke들이 있는데 대표적인 Hook이 바로 useEffect Hook입니다. useEffect Hook은 componentDidMount, componentDidUpdate, componentWillUpdate, componentWillUnmount의 기능을 수행할 수 있습니다. 컴포넌트는 랜더링을 통해 뷰를 생성하는게 주 임무이지만 API호출, 이벤트 추가 등 부가적인 효과(side effect)를 필요로 하므로 이때 사용하라고 use(side)Effect라는 함수명을 갖게 되었습니다.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nimport React, { useState, useEffect } from &#39;react&#39;;\n\nfunction Test({}){\n  const [count, setCount] = useState(0);\n  const [fruit, setFruit] = useState(&#39;apple&#39;);\n\n  useEffect(()=&amp;gt; {\n    console.log(&#39;component did mount or update!&#39;);\n  });\n\n  useEffect(()=&amp;gt; {\n    console.log(&#39;component did mount!&#39;);\n  }, []);\n\n  useEffect(()=&amp;gt; {\n    console.log(&#39;count up!&#39;);\n  }, [count]);\n\n  useEffect(()=&amp;gt;{\n    console.log(&#39;effect&#39;, count);\n    return () =&amp;gt; { \n      console.log(&#39;component will update or will unmount!&#39;, count);\n    }\n  });\n\n  return (&amp;lt;div&amp;gt;\n    &amp;lt;button type=&quot;button&quot; onClick={()=&amp;gt;{ setCount(count + 1); }}&amp;gt;{count}&amp;lt;/button&amp;gt;\n    &amp;lt;input type=&quot;text&quot; onChange={(e)=&amp;gt;{ setFruit(e.target.value) }}/&amp;gt;\n  &amp;lt;/div&amp;gt;)\n}\n\n\nuseEffect Hook은 첫 번째 파라미터로 실행될 함수를, 두 번째 파라미터로 첫 번째 파라미터의 실행 조건이 될 prop이나 state들을 배열로 받습니다. 실행되는 시점은 랜더링이 끝나고 컴포넌트가 마운드 된 후입니다. 처음 마운트(componentDidMount)때는 무조건 시행이 되고 이후 마운트(componentDidUpdate)부터는 실행 조건 배열에 넣은 값들이 변경되었을 때만 실행됩니다. 실행 조건 배열을 넣어주지 않으면 처음 마운트 될 때만 실행이 되며 빈 배열([])을 넣어주게 되면 다시 렌더링 될 때마다 무조건 실행됩니다. 뒷정리 함수라고 불리는 함수를 리턴하기도 하는데 컴포넌트가 업데이트되기 전 또는 마운트가 해제되기 전에 실행되며 이벤트 해제, 리소스 반환 등의 작업을 할 수 있게 해줍니다.\n\n\n\nuseMemo Hook\n\n이번에는 예제를 먼저 보시길 바랍니다.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nimport React, { useState } from &quot;react&quot;;\n\nfunction getPrice(strArray) {\n  console.log(&#39;compute...&#39;);\n  return strArray.reduce((acc, el) =&amp;gt; acc + el.length, 0);\n}\n\nfunction Basket() {\n  const [input, setInput] = useState(&quot;&quot;);\n  const [fruits, setFruits] = useState([&quot;apple&quot;, &quot;banana&quot;]);\n  return (\n    &amp;lt;div&amp;gt;\n      &amp;lt;input\n        type=&quot;text&quot;\n        value={input}\n        onChange={e =&amp;gt; {\n          setInput(e.target.value);\n        }}\n      /&amp;gt;\n      &amp;lt;button\n        onClick={() =&amp;gt; {\n          setFruits(fruits.concat([input]));\n        }}\n      &amp;gt;\n        Add\n      &amp;lt;/button&amp;gt;\n      &amp;lt;ul&amp;gt;\n        {fruits.map(el =&amp;gt; (\n          &amp;lt;li key={el}&amp;gt;{el}&amp;lt;/li&amp;gt;\n        ))}\n      &amp;lt;/ul&amp;gt;\n      &amp;lt;p&amp;gt;가격 : {getPrice(fruits)}원&amp;lt;/p&amp;gt;\n    &amp;lt;/div&amp;gt;\n  );\n}\n\n\n간단한 장바구니 컴포넌트입니다. 사용자가 문자열을 입력하고 Add버튼을 누르면 문자열이 fruits에 추가됩니다. 예제의 끝 부분에서 getPrice라는 함수가 하는 역할은 담긴 각 과일들의 문자열 길이를 더해서 가격을 계산합니다. getPrice함수는 렌더링 될 때마다 실행이 되므로 Add버튼이 클릭되었을 때만 실행되는 것이 아닌 타이핑 될 때마다 실행이 되므로 비 효율적입닏다. 지금은 getPrice함수가 간단하지만 API를 호출하는 등, 시간이 오래 걸리는 함수라면 최적화가 필요할 것입니다. Add버튼이 눌릴 때만 가격이 계산되도록 Memo Hook을 사용해 보도록 하겠습니다.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nimport React, { useState } from &quot;react&quot;;\n\nfunction getPrice(strArray) {\n  console.log(&#39;compute...&#39;);\n  return strArray.reduce((acc, el) =&amp;gt; acc + el.length, 0);\n}\n\nfunction Basket() {\n  const [input, setInput] = useState(&quot;&quot;);\n  const [fruits, setFruits] = useState([&quot;apple&quot;, &quot;banana&quot;]);\n  const price = useMemo(() =&amp;gt; getPrice(fruits), [fruits]);\n  return (\n    &amp;lt;div&amp;gt;\n      &amp;lt;input\n        type=&quot;text&quot;\n        value={input}\n        onChange={e =&amp;gt; {\n          setInput(e.target.value);\n        }}\n      /&amp;gt;\n      &amp;lt;button\n        onClick={() =&amp;gt; {\n          setFruits(fruits.concat([input]));\n        }}\n      &amp;gt;\n        Add\n      &amp;lt;/button&amp;gt;\n      &amp;lt;ul&amp;gt;\n        {fruits.map(el =&amp;gt; (\n          &amp;lt;li key={el}&amp;gt;{el}&amp;lt;/li&amp;gt;\n        ))}\n      &amp;lt;/ul&amp;gt;\n      &amp;lt;p&amp;gt;가격 : {price}원&amp;lt;/p&amp;gt;\n    &amp;lt;/div&amp;gt;\n  );\n}\n\n\n11번째 라인이 추가되었고 33번째 라인이 변경되었습니다. useMomo Hook은 useEffect Hook과 사용하는 방법은 똑같지만 실행 시점이 마운트된 후, 업데이트 후, 마운트 해제 후(뒷정리 함수)가 아닌 렌더 되기 전이라고 생각하시면 됩니다.\n\n\n\n사용자 정의 Hooks\n\n앞에서는 대표적인 Hooks들을 알아 봤습니다. React Hooks의 진정한 장점은 React에서 제공해주는 Hooks를 조합하고 응용해서 새로운 Hooks를 생성할 수 있다는 점입니다. useState Hook을 사용해서 배열을 관리하는 Hook을 만든 뒤 앞선 Basket 컴포넌트에서 사용해 보도록 하겠습니다.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nimport React, { useState, useMemo } from &quot;react&quot;;\n\nfunction useArray(initArray = []) {\n  const [array, setArray] = useState(initArray);\n  const push = el =&amp;gt; {\n    setArray(array.concat([el]));\n  };\n  const clear = () =&amp;gt; {\n    setArray([]);\n  };\n  return [array, push, clear];\n}\n\nfunction getPrice(strArray) {\n  console.log(&quot;compute...&quot;);\n  return strArray.reduce((acc, el) =&amp;gt; acc + el.length, 0);\n}\n\nfunction Basket() {\n  const [input, setInput] = useState(&quot;&quot;);\n  const [fruits, pushFruit, clearFruit] = useArray([&quot;apple&quot;, &quot;banana&quot;]);\n  const price = useMemo(() =&amp;gt; getPrice(fruits), [fruits]);\n  return (\n    &amp;lt;div&amp;gt;\n      &amp;lt;input\n        type=&quot;text&quot;\n        value={input}\n        onChange={e =&amp;gt; {\n          setInput(e.target.value);\n        }}\n      /&amp;gt;\n      &amp;lt;button\n        onClick={() =&amp;gt; {\n          pushFruit(input);\n        }}\n      &amp;gt;\n        Add\n      &amp;lt;/button&amp;gt;\n      &amp;lt;button\n        onClick={() =&amp;gt; {\n          clearFruit();\n        }}\n      &amp;gt;\n        Clear\n      &amp;lt;/button&amp;gt;\n      &amp;lt;ul&amp;gt;\n        {fruits.map(el =&amp;gt; (\n          &amp;lt;li key={el}&amp;gt;{el}&amp;lt;/li&amp;gt;\n        ))}\n      &amp;lt;/ul&amp;gt;\n      &amp;lt;p&amp;gt;가격 : {price}&amp;lt;/p&amp;gt;\n    &amp;lt;/div&amp;gt;\n  );\n}\n\n\n이러한 사용자 정의 Hooks는 컴포넌트에서 로직을 별도의 함수로 분리해 내어 가독성과 재사용성을 크게 높여주며 컴포넌트가 뷰에만 집중할 수 있도록 도와줍니다. 개인적으로 Hooks를 사용하면서 함수형 프로그래밍을 하고 있다는 느낌을 강하게 받기도 했습니다. 또한 사용자 정의 Hooks는 직접 만들어서 사용할 수도 있지만 다른 개발자 분들이 이미 만들어 놓은 Hooks를 라이브러리처럼 사용할수도 있습니다. 이를 통해 개발 생산성을 크게 높일 수도 있습니다.\n"
      } ,
   
      {
        "title"    : "AJAX의 등장에 따른 웹 개발 패턴의 변화",
        "category" : "",
        "tags"     : " ajax, ssr, ajax, web",
        "url"      : "/2019/06/30/CSR-SSR.html",
        "date"     : "June 30, 2019",
        "excerpt"  : "들어가며\n\n1990년 월드와이드웹이 발표된 이래로 웹은 현재까지 많은 발전을 거듭해 왔습니다. 정보를 제공하는 사람은 더 많은 정보를 효율적으로 전달하고 싶어 했고 이용자의 요구사항도 높아져만 갔습니다. 이에 부응하기 위해 수많은 라이브러리, 프레임워크, 개발 패턴들이 탄생하였고 현재의 거대하고 다양한 웹 개발 문화가 만들어졌습니다. 그중 이번 포스팅에서는 AJAX 등장 이후의 개발 패턴의 변화라는 ...",
        "content"  : "들어가며\n\n1990년 월드와이드웹이 발표된 이래로 웹은 현재까지 많은 발전을 거듭해 왔습니다. 정보를 제공하는 사람은 더 많은 정보를 효율적으로 전달하고 싶어 했고 이용자의 요구사항도 높아져만 갔습니다. 이에 부응하기 위해 수많은 라이브러리, 프레임워크, 개발 패턴들이 탄생하였고 현재의 거대하고 다양한 웹 개발 문화가 만들어졌습니다. 그중 이번 포스팅에서는 AJAX 등장 이후의 개발 패턴의 변화라는 주제에 대해 다뤄 보려고 합니다.\n\n\n\nBefore AJAX, After AJAX\n\n웹의 역사에 큰 획을 그을만한 중요한 사건이 몇 가지가 있는데 그중 하나가 AJAX의 등장입니다. AJAX(Asynchronous Javascript And XML)은 브라우저의 JS엔진과 웹서버가 XML(또는 JSON)을 매개로 하여 비동기적으로 통신할 수 있는 기술입니다.\n\n \n\n\n\n요즘의 웹서비스는 많은 기능을 포함하고 있기 때문에 단순하게 정보를 표현해 주는 “웹 페이지” 보다 하나의 독립적인 프로그램인 “웹 애플리케이션”이라는 용어가 더 어울립니다. 유연한 인터페이스를 통해 은 사용자와 상호작용하며 사용자가 원하는 정보를 효과적으로 표현해 줍니다.\n\n사용자가 원하는 데이터들은 데이터베이스에 의해서 관리되고 브라우저는 데이터베이스와 직접 통신할 수 없기 때문에 현재 서버에 새로운 요청을 하면 서버는 그 요청에 맞는 데이터를 데이터베이스에서 검색한 후 적절한 페이지를 생성하기 위해 HTML을 만드는 작업(랜더링)을 진행하게 됩니다. 이렇게 랜더링 된 새로운 페이지를 브라우저는 응답받고 현재 사용자가 보던 페이지를 새롭게 응답받은 페이지로 교체하게 됩니다.\n\n\n\n\n이러한 형태의 통신이 AJAX가 탄생하기 이전에 사용자에게 새로운 정보를 표현하기 위한 작업의 일반적인 흐름이었습니다. “새로운 정보” = “새로운 페이지”의 공식이었기 때문에 90%가 이전 페이지와 똑같고 10%만 달라도 서버는 무조건 100%를 다시 그려야 하는 비효율적인 작업을 반복해야 했습니다. 서버에서 모든 페이지를 직접 그려서 응답하기 때문에 이러한 방식을 SSR(Server Side Rendering)이라고 합니다.\n\n\n\n단순히 제목만 Home에서 Info바뀌어도 모든 페이지를 다시 서버에서 받아와서 교체\n\n\nAJAX 기반의 통신방식은 요청할 때 새로운 전체 페이지를 응답받는 것이 아닌 페이지의 일부 또는 데이터만 응답받을 수 있고 현재 사용자에게 보이는 페이지가 사라지지 않습니다. 전체 페이지를 새로운 페이지로 교체하는 것이 아니라 그대로 유지하면서 변경되어야 할 부분만 서버로부터 받은 페이지의 일부분으로 교체하거나 서버로부터 받은 데이터를 가지고 브라우저에서 직접 HTML을 생성한 뒤 교체하게 됩니다.\n\n\n페이지를 교체하지 않고 변경된 부분에 해당하는 데이터만 받아와서 교체\n\n\n이러한 방식의 장점을 세 가지로 요약하면 다음과 같습니다.\n\n\n  통신할 데이터의 용량이 현저히 줄어들기 때문에 경제적으로 이득\n  변경되어야 할 부분만 교체하기 때문에 페이지 교체 시간이 적게 걸려 로딩 시간이 짧아 응답성을 향상\n  작업이 비동기적으로 수행되기 때문에 통신이 진행되는 동안 사용자는 계속해서 페이지를 이용 가능\n\n\n물론 장점 이외에도 복잡한 DOM 조작, 지원하지 않는 브라우저, 디버깅 등의 단점들도 존재합니다.\n\n\n\nCSR(Client Side Rendering)와 SPA(Single Page Application)\n\nAJAX 기반의 통신방식은 웹 개발 진영에 많은 변화를 가져왔습니다. 웹 개발방식은 기업마다 다를 수 있고 개발자마다 다를 수 있습니다. AJAX을 프로젝트에 적극적으로 도입하는 개발자들도 있었고 아이디 중복확인, 검색어 추천 등 현재 페이지를 유지하면서 서버와 통신해야 하는 필수적인 부분에만 사용하기도 했습니다. 앞서 말한 적극적으로 AJAX를 도입하던 개발자 그리고 팀들은 더 쉽고 빠르게 AJAX 방식으로 웹앱을 제작하길 원했고 오픈소스 라이브러리들과 프레임워크들이 하나둘 등장하기 시작했습니다. AngularJS, BackboneJS, EmberJS 등의 프레임워크들이 인기를 끌기 시작했고 시간이 더 지나면서  뷰레이어에만 집중하며 비교적 가벼우면서도 학습곡선이 낮은 ReactJS, VueJS등의 라이브러리들의 인기가 점차 높아지고 있습니다.\n\n\n\n\n이러한 프레임워크 또는 라이브러리를 이용하여 만들어진 웹앱 일반적으로 다음과 같은 구조를 띠게 됩니다. 맨 처음 요청할 때 서버는 내용이 없고 페이지의 구조(뼈대)에 해당하는 HTML을 응답해 줍니다. 당연히 내용(알맹이)에 해당하는 부분이 없기 때문에 사용자에게는 의미 없는 페이지입니다. 하지만 해당 페이지에는 JS 링크가 들어있고 해당 JS 코드가 실행되면서 내용이 렌더링 됩니다. 만약 표시해야 할 내용이 데이터베이스에 보관되어있다면 AJAX요청에 의해 서버로부터 데이터를 받아온 후 내용을 화면에 랜더링 합니다. 사용자가 다른 내용을 보고 싶어서 링크 혹은 버튼을 클릭 하거나 특정한 이벤트를 발생시키면 다시 JS 코드에 의해서 해당 내용이 렌더링 됩니다.\n\n\n기본페이지 예시, bar.js안에 들어있는 js코드에 의해 화면이 랜더링\n\n\n서버는 초기 요청 시에만 기본 뼈대에 해당하는 페이지를 응답할 뿐 전혀 데이터를 가지고 HTML 코드를 랜더링하는 작업을 하지 않으며 AJAX 요청이 올 때에는 응답해야할 데이터를 데이터베이스(또는 세션, 다른 API서버, 파일 등)에서 찾아서 응답하기만 해줄 뿐입니다. 따라서 클라이언트에서 페이지를 직접 렌더링 하기 때문에 이러한 방식을 CSR(Client Side Rendering)이라고 하며 기본페이지는 계속 유지되면서 JS코드에의해 내용이 변경되므로 “페이지가 하나다”라고 하여 SPA(Single Page Application)라고 부릅니다. CSR, SPA의 장점은 AJAX의 장점이며 하나 정도를 더 추가하자면 클라이언트와 서버의 역할이 명확해지므로 협업이 용이하다는 점이 있습니다.\n\n\n\n\nCSR의 단점\n\n앞선 내용만으로는 CSR이 우주최강 로봇인 것 같지만 커다란 단점 두 가지를 가지고 있습니다. 첫 번째는 최초 로딩속도가 느리다 입니다. 이유는 처음 요청 시 웹앱에 필요한 대부분의 JS파일 CSS파일들을 서버로부터 응답받아야 하며 이를 화면에 표시하기 위해서 브라우저가 열심히 작업을 수행해야 하기 때문입니다. 뿐만아니라 웹앱의 규모가 크고 사용자PC의 사양이 높지 못하다면 기존 방식인 서버에서 직접 페이지를 렌더링하는 SSR 방식이 오히려 빠를 수도 있습니다. 물론 요즘 PC 사양이 상향 평준화 되었고 브라우저의 성능도 획기적으로 발전되고 있지만, 서비스의 성격과 대상에 따라서 단점이 부각될 수도 있습니다.\n\n두 번째는 검색엔진 노출에 관련된 문제입니다. CSR은 초기 요청에는 뼈대에 해당하는 페이지밖에 응답이 안 되고 JS가 동작 하면서 내용이 채워지는 방식인데 구글 검색엔진을 제외한 검색엔진은 페이지에 포함된 자바스크립트를 실행하여 완성된 결과화면을 인덱싱하지 않습니다. 기술적인 측면도 있겠지만 아무래도 경제적인 측면이 클 것입니다. 하루에도 수 많은 웹사이트들이 생겨나고 업데이트 되기 때문입니다. 따라서 CSR 방식은 구글을 제외한 나머지 검색엔진에 노출되기 어렵습니다. 이는 마케팅을 목적으로 하는 서비스일 경우에는 심각한 단점이 될 수도 있습니다.\n\n\n\nCSR + SSR\n\n기존 방식인 SSR을 따르자니 CSR의 장점이 너무 매력적이고 CSR을 따르자니 앞서 말한 두 개의 단점이 크게 작용하는 서비스라면 웹 개발자는 고민에 빠질 수 밖에 없을 것입니다. 두 가지의 선택지가 장단점이 명확하다면 두 가지 선택지의 장점을 합한 제 3의 선택지를 만드는 게 최선의 선택지라고 생각합니다.  즉, 초기 요청 시에만 서버에서 완성된 페이지를 응답해 주고 나머지는 CSR 방식을 따라가면 됩니다. 이렇게 되면 CSR 방식의 단점을 완벽히는 아니지만 어느 정도 해결할 수 있습니다. 성능이 좋은 서버가 첫 페이지를 빠르게 그려주면 사용자는 초기 화면을 빨리 볼 수 있어서 좋고 검색엔진도 완성된 페이지 인덱싱이 가능합니다. 다행히도 Angular, Ember.js같은 프레임워크와 ReactJS, VueJS같은 라이브러리들은 SSR을 지원하고 있습니다.  더군다나 React 진영에는 Next.js, Vue진영에는 Nuxt.js라는 프레임웍이 있어 어렵지 않게 CSR과 SSR의 이점을 동시에 이용할 수 있습니다.\n\n\n첫 요청은 서버에서 랜더링된 HTML코드를 응답, 이후에는  필요한 데이터만 AJAX요청\n\n\n\n"
      } 
   
   ,
   
     {
       
          "title"    : "Ninja",
          "category" : "",
          "tags"     : " Lorem",
          "url"      : "/portfolio/ninja",
          "date"     : "April 8, 2014",
          "excerpt"  : "<p><img src=\"/assets/img/portfolio/ninja.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architec...",
          "content"  : "<p><img src=\"/assets/img/portfolio/ninja.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architec..."
       
     } ,
   
     {
       
          "title"    : "Creative",
          "category" : "",
          "tags"     : " Ipsum",
          "url"      : "/portfolio/safe",
          "date"     : "August 16, 2014",
          "excerpt"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <...",
          "content"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <..."
       
     } ,
   
     {
       
          "title"    : "Circus",
          "category" : "",
          "tags"     : " Ipsum",
          "url"      : "/portfolio/circus",
          "date"     : "September 1, 2014",
          "excerpt"  : "<p><img src=\"/assets/img/portfolio/circus.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi archite...",
          "content"  : "<p><img src=\"/assets/img/portfolio/circus.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi archite..."
       
     } ,
   
     {
       
          "title"    : "Tower of Hanoi",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/hanoi",
          "date"     : "September 1, 2014",
          "excerpt"  : "<p><img src=\"/assets/img/portfolio/toh.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto...",
          "content"  : "<p><img src=\"/assets/img/portfolio/toh.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto..."
       
     } ,
   
     {
       
          "title"    : "Tic tac toe",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/tictactoe",
          "date"     : "September 1, 2014",
          "excerpt"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <...",
          "content"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <..."
       
     } ,
   
     {
       
          "title"    : "Cake",
          "category" : "",
          "tags"     : " Lorem, Ipsum, Portfolio",
          "url"      : "/portfolio/cake",
          "date"     : "September 27, 2015",
          "excerpt"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <...",
          "content"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <..."
       
     } ,
   
     {
       
          "title"    : "Jekyll",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/jekyllblog",
          "date"     : "May 26, 2017",
          "excerpt"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <...",
          "content"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <..."
       
     } ,
   
     {
       
          "title"    : "Lorem Ipsum",
          "category" : "",
          "tags"     : " ",
          "url"      : "/portfolio/submarine",
          "date"     : "September 3, 2017",
          "excerpt"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <...",
          "content"  : "<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem <..."
       
     } ,
   
     {
       
          "title"    : "Github",
          "category" : "",
          "tags"     : " Lorem, Portfolio",
          "url"      : "/portfolio/gitlecture",
          "date"     : "October 20, 2017",
          "excerpt"  : "<p><img src=\"/assets/img/portfolio/github.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi archite...",
          "content"  : "<p><img src=\"/assets/img/portfolio/github.png\" alt=\"image\" /></p>\n\n<p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi archite..."
       
     } 
   
]